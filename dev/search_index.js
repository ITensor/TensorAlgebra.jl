var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#TensorAlgebra.add!-Tuple{AbstractArray, AbstractArray, Number, Number}","page":"Reference","title":"TensorAlgebra.add!","text":"add!(dest, src, α, β)\n\nEquivalent to dest .= β .* dest .+ α .* src, but maybe with a more optimized/specialized implementation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TensorAlgebra.add!-Tuple{AbstractArray, AbstractArray}","page":"Reference","title":"TensorAlgebra.add!","text":"add!(dest, src)\n\nEquivalent to dest .+= src, but maybe with a more optimized/specialized implementation. Generally calls add!(dest, src, true, true).\n\n\n\n\n\n","category":"method"},{"location":"reference/#TensorAlgebra.eigen","page":"Reference","title":"TensorAlgebra.eigen","text":"eigen(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> D, V\neigen(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> D, V\neigen(A::AbstractArray, ndims_codomain::Val; kwargs...) -> D, V\neigen(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> D, V\n\nCompute the eigenvalue decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation.\n\nKeyword arguments\n\nishermitian::Bool: specify if the matrix is Hermitian, which can be used to speed up the computation. If false, the output eltype will always be <:Complex.\ntrunc: Truncation keywords for eig(h)_trunc.\nOther keywords are passed on directly to MatrixAlgebraKit.\n\nSee also MatrixAlgebraKit.eig_full!, MatrixAlgebraKit.eig_trunc!, MatrixAlgebraKit.eig_vals!, MatrixAlgebraKit.eigh_full!, MatrixAlgebraKit.eigh_trunc!, and MatrixAlgebraKit.eigh_vals!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.eigvals","page":"Reference","title":"TensorAlgebra.eigvals","text":"eigvals(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> D\neigvals(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> D\neigvals(A::AbstractArray, ndims_codomain::Val; kwargs...) -> D\neigvals(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> D\n\nCompute the eigenvalues of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation. The output is a vector of eigenvalues.\n\nKeyword arguments\n\nishermitian::Bool: specify if the matrix is Hermitian, which can be used to speed up the computation. If false, the output eltype will always be <:Complex.\nOther keywords are passed on directly to MatrixAlgebraKit.\n\nSee also MatrixAlgebraKit.eig_vals! and MatrixAlgebraKit.eigh_vals!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.factorize","page":"Reference","title":"TensorAlgebra.factorize","text":"factorize(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> X, Y\nfactorize(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> X, Y\nfactorize(A::AbstractArray, ndims_codomain::Val; kwargs...) -> X, Y\nfactorize(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> X, Y\n\nCompute the decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation.\n\nKeyword arguments\n\north::Symbol=:left: specify the orthogonality of the decomposition. Currently only :left and :right are supported.\nOther keywords are passed on directly to MatrixAlgebraKit.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.left_null","page":"Reference","title":"TensorAlgebra.left_null","text":"left_null(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> N\nleft_null(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> N\nleft_null(A::AbstractArray, ndims_codomain::Val; kwargs...) -> N\nleft_null(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> N\n\nCompute the left nullspace of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation. The output satisfies N' * A ≈ 0 and N' * N ≈ I.\n\nKeyword arguments\n\natol::Real=0: absolute tolerance for the nullspace computation.\nrtol::Real=0: relative tolerance for the nullspace computation.\nkind::Symbol: specify the kind of decomposition used to compute the nullspace. The options are :qr, :qrpos and :svd. The former two require 0 == atol == rtol. The default is :qrpos if atol == rtol == 0, and :svd otherwise.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.left_orth","page":"Reference","title":"TensorAlgebra.left_orth","text":"left_orth(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> V, C\nleft_orth(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> V, C\nleft_orth(A::AbstractArray, ndims_codomain::Val; kwargs...) -> V, C\nleft_orth(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> V, C\n\nCompute the left orthogonal decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation.\n\nKeyword arguments\n\nKeyword arguments are passed on directly to MatrixAlgebraKit.\n\nSee also MatrixAlgebraKit.left_orth!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.left_polar","page":"Reference","title":"TensorAlgebra.left_polar","text":"left_polar(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> W, P\nleft_polar(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> W, P\nleft_polar(A::AbstractArray, ndims_codomain::Val; kwargs...) -> W, P\nleft_polar(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> W, P\n\nCompute the left polar decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation.\n\nKeyword arguments\n\nKeyword arguments are passed on directly to MatrixAlgebraKit.\n\nSee also MatrixAlgebraKit.left_polar!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.lq","page":"Reference","title":"TensorAlgebra.lq","text":"lq(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> L, Q\nlq(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> L, Q\nlq(A::AbstractArray, ndims_codomain::Val; kwargs...) -> L, Q\nlq(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> L, Q\n\nCompute the LQ decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation.\n\nKeyword arguments\n\nfull::Bool=false: select between a \"full\" or a \"compact\" decomposition, where Q is unitary or L is square, respectively.\npositive::Bool=false: specify if the diagonal of L should be positive, leading to a unique decomposition.\nOther keywords are passed on directly to MatrixAlgebraKit.\n\nSee also MatrixAlgebraKit.lq_full! and MatrixAlgebraKit.lq_compact!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.permutedimsadd!-Tuple{AbstractArray, AbstractArray, Any, Number, Number}","page":"Reference","title":"TensorAlgebra.permutedimsadd!","text":"permutedimsadd!(dest, src, perm, α, β)\n\ndest = β * dest + α * permutedims(src, perm).\n\n\n\n\n\n","category":"method"},{"location":"reference/#TensorAlgebra.qr","page":"Reference","title":"TensorAlgebra.qr","text":"qr(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> Q, R\nqr(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> Q, R\nqr(A::AbstractArray, ndims_codomain::Val; kwargs...) -> Q, R\nqr(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> Q, R\n\nCompute the QR decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation.\n\nKeyword arguments\n\nfull::Bool=false: select between a \"full\" or a \"compact\" decomposition, where Q is unitary or R is square, respectively.\npositive::Bool=false: specify if the diagonal of R should be positive, leading to a unique decomposition.\nOther keywords are passed on directly to MatrixAlgebraKit.\n\nSee also MatrixAlgebraKit.qr_full! and MatrixAlgebraKit.qr_compact!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.right_null","page":"Reference","title":"TensorAlgebra.right_null","text":"right_null(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> Nᴴ\nright_null(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> Nᴴ\nright_null(A::AbstractArray, ndims_codomain::Val::Val; kwargs...) -> Nᴴ\nright_null(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> Nᴴ\n\nCompute the right nullspace of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation. The output satisfies A * Nᴴ' ≈ 0 and Nᴴ * Nᴴ' ≈ I.\n\nKeyword arguments\n\natol::Real=0: absolute tolerance for the nullspace computation.\nrtol::Real=0: relative tolerance for the nullspace computation.\nkind::Symbol: specify the kind of decomposition used to compute the nullspace. The options are :lq, :lqpos and :svd. The former two require 0 == atol == rtol. The default is :lqpos if atol == rtol == 0, and :svd otherwise.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.right_orth","page":"Reference","title":"TensorAlgebra.right_orth","text":"right_orth(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> C, V\nright_orth(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> C, V\nright_orth(A::AbstractArray, ndims_codomain::Val; kwargs...) -> C, V\nright_orth(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> C, V\n\nCompute the right orthogonal decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation.\n\nKeyword arguments\n\nKeyword arguments are passed on directly to MatrixAlgebraKit.\n\nSee also MatrixAlgebraKit.right_orth!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.right_polar","page":"Reference","title":"TensorAlgebra.right_polar","text":"right_polar(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> P, W\nright_polar(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> P, W\nright_polar(A::AbstractArray, ndims_codomain::Val; kwargs...) -> P, W\nright_polar(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> P, W\n\nCompute the right polar decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation.\n\nKeyword arguments\n\nKeyword arguments are passed on directly to MatrixAlgebraKit.\n\nSee also MatrixAlgebraKit.right_polar!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.svd","page":"Reference","title":"TensorAlgebra.svd","text":"svd(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> U, S, Vᴴ\nsvd(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> U, S, Vᴴ\nsvd(A::AbstractArray, ndims_codomain::Val; kwargs...) -> U, S, Vᴴ\nsvd(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> U, S, Vᴴ\n\nCompute the SVD decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation.\n\nKeyword arguments\n\nfull::Bool=false: select between a \"thick\" or a \"thin\" decomposition, where both U and Vᴴ are unitary or isometric.\ntrunc: Truncation keywords for svd_trunc. Not compatible with full=true.\nOther keywords are passed on directly to MatrixAlgebraKit.\n\nSee also MatrixAlgebraKit.svd_full!, MatrixAlgebraKit.svd_compact!, and MatrixAlgebraKit.svd_trunc!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.svdvals","page":"Reference","title":"TensorAlgebra.svdvals","text":"svdvals(A::AbstractArray, labels_A, labels_codomain, labels_domain) -> S\nsvdvals(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}) -> S\nsvdvals(A::AbstractArray, ndims_codomain::Val) -> S\nsvdvals(A::AbstractArray, biperm::AbstractBlockPermutation{2}) -> S\n\nCompute the singular values of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation. The output is a vector of singular values.\n\nSee also MatrixAlgebraKit.svd_vals!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.MatrixAlgebra.truncdegen-Tuple{MatrixAlgebraKit.TruncationStrategy}","page":"Reference","title":"TensorAlgebra.MatrixAlgebra.truncdegen","text":"truncdegen(trunc::TruncationStrategy; atol::Real=0, rtol::Real=0)\n\nModify a truncation strategy so that if the truncation falls within a degenerate subspace, the entire subspace gets truncated as well. A value val is considered degenerate if norm(val - truncval) ≤ max(atol, rtol * norm(truncval)) where truncval is the largest value truncated by the original truncation strategy trunc.\n\nFor now, this truncation strategy assumes the spectrum being truncated has already been reverse sorted and the strategy being wrapped outputs a contiguous subset of values including the largest one. It also only truncates for now, so may not respect if a minimum dimension was requested in the strategy being wrapped. These restrictions may be lifted in the future or provided through a different truncation strategy.\n\n\n\n\n\n","category":"method"},{"location":"#TensorAlgebra.jl","page":"Home","title":"TensorAlgebra.jl","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue) (Image: Aqua)","category":"section"},{"location":"#Support","page":"Home","title":"Support","text":"<img class=\"display-light-only\" src=\"assets/CCQ.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n<img class=\"display-dark-only\" src=\"assets/CCQ-dark.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n\nTensorAlgebra.jl is supported by the Flatiron Institute, a division of the Simons Foundation.","category":"section"},{"location":"#Installation-instructions","page":"Home","title":"Installation instructions","text":"This package resides in the ITensor/ITensorRegistry local registry. In order to install, simply add that registry through your package manager. This step is only required once.\n\njulia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url = \"https://github.com/ITensor/ITensorRegistry\")\n\nor:\n\njulia> Pkg.Registry.add(url = \"git@github.com:ITensor/ITensorRegistry.git\")\n\nif you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages.\n\nThen, the package can be added as usual through the package manager:\n\njulia> Pkg.add(\"TensorAlgebra\")","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"using TensorAlgebra: TensorAlgebra\n\nExamples go here.\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
