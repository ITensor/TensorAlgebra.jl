var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [TensorAlgebra]","category":"page"},{"location":"reference/#TensorAlgebra.eigen-Tuple{AbstractArray, Any, Any, Any}","page":"Reference","title":"TensorAlgebra.eigen","text":"eigen(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> D, V\neigen(A::AbstractArray, biperm::BlockedPermutation{2}; kwargs...) -> D, V\n\nCompute the eigenvalue decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels, or directly through a biperm.\n\nKeyword arguments\n\nishermitian::Bool: specify if the matrix is Hermitian, which can be used to speed up the   computation. If false, the output eltype will always be <:Complex.\ntrunc: Truncation keywords for eig(h)_trunc.\nOther keywords are passed on directly to MatrixAlgebraKit.\n\nSee also MatrixAlgebraKit.eig_full!, MatrixAlgebraKit.eig_trunc!, MatrixAlgebraKit.eig_vals!, MatrixAlgebraKit.eigh_full!, MatrixAlgebraKit.eigh_trunc!, and MatrixAlgebraKit.eigh_vals!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TensorAlgebra.eigvals-Tuple{AbstractArray, Any, Any, Any}","page":"Reference","title":"TensorAlgebra.eigvals","text":"eigvals(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> D\neigvals(A::AbstractArray, biperm::BlockedPermutation{2}; kwargs...) -> D\n\nCompute the eigenvalues of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels, or directly through a biperm. The output is a vector of eigenvalues.\n\nKeyword arguments\n\nishermitian::Bool: specify if the matrix is Hermitian, which can be used to speed up the   computation. If false, the output eltype will always be <:Complex.\nOther keywords are passed on directly to MatrixAlgebraKit.\n\nSee also MatrixAlgebraKit.eig_vals! and MatrixAlgebraKit.eigh_vals!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TensorAlgebra.factorize","page":"Reference","title":"TensorAlgebra.factorize","text":"factorize(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> X, Y\nfactorize(A::AbstractArray, biperm::BlockedPermutation{2}; kwargs...) -> X, Y\n\nCompute the decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels, or directly through a biperm.\n\nKeyword arguments\n\north::Symbol=:left: specify the orthogonality of the decomposition. Currently only :left and :right are supported.\nOther keywords are passed on directly to MatrixAlgebraKit.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.left_null-Tuple{AbstractArray, Any, Any, Any}","page":"Reference","title":"TensorAlgebra.left_null","text":"left_null(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> N\nleft_null(A::AbstractArray, biperm::BlockedPermutation{2}; kwargs...) -> N\n\nCompute the left nullspace of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels, or directly through a biperm. The output satisfies N' * A ≈ 0 and N' * N ≈ I.\n\nKeyword arguments\n\natol::Real=0: absolute tolerance for the nullspace computation.\nrtol::Real=0: relative tolerance for the nullspace computation.\nkind::Symbol: specify the kind of decomposition used to compute the nullspace. The options are :qr, :qrpos and :svd. The former two require 0 == atol == rtol. The default is :qrpos if atol == rtol == 0, and :svd otherwise.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TensorAlgebra.left_orth","page":"Reference","title":"TensorAlgebra.left_orth","text":"left_orth(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> V, C\nleft_orth(A::AbstractArray, biperm::BlockedPermutation{2}; kwargs...) -> V, C\n\nCompute the left orthogonal decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels, or directly through a biperm.\n\nKeyword arguments\n\nKeyword arguments are passed on directly to MatrixAlgebraKit.\n\nSee also MatrixAlgebraKit.left_orth!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.left_polar","page":"Reference","title":"TensorAlgebra.left_polar","text":"left_polar(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> W, P\nleft_polar(A::AbstractArray, biperm::BlockedPermutation{2}; kwargs...) -> W, P\n\nCompute the left polar decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels, or directly through a biperm.\n\nKeyword arguments\n\nKeyword arguments are passed on directly to MatrixAlgebraKit.\n\nSee also MatrixAlgebraKit.left_polar!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.lq","page":"Reference","title":"TensorAlgebra.lq","text":"lq(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> L, Q\nlq(A::AbstractArray, biperm::BlockedPermutation{2}; kwargs...) -> L, Q\n\nCompute the LQ decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels, or directly through a biperm.\n\nKeyword arguments\n\nfull::Bool=false: select between a \"full\" or a \"compact\" decomposition, where Q is unitary or L is square, respectively.\npositive::Bool=false: specify if the diagonal of L should be positive, leading to a unique decomposition.\nOther keywords are passed on directly to MatrixAlgebraKit.\n\nSee also MatrixAlgebraKit.lq_full! and MatrixAlgebraKit.lq_compact!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.qr","page":"Reference","title":"TensorAlgebra.qr","text":"qr(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> Q, R\nqr(A::AbstractArray, biperm::BlockedPermutation{2}; kwargs...) -> Q, R\n\nCompute the QR decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels, or directly through a biperm.\n\nKeyword arguments\n\nfull::Bool=false: select between a \"full\" or a \"compact\" decomposition, where Q is unitary or R is square, respectively.\npositive::Bool=false: specify if the diagonal of R should be positive, leading to a unique decomposition.\nOther keywords are passed on directly to MatrixAlgebraKit.\n\nSee also MatrixAlgebraKit.qr_full! and MatrixAlgebraKit.qr_compact!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.right_null-Tuple{AbstractArray, Any, Any, Any}","page":"Reference","title":"TensorAlgebra.right_null","text":"right_null(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> Nᴴ\nright_null(A::AbstractArray, biperm::BlockedPermutation{2}; kwargs...) -> Nᴴ\n\nCompute the right nullspace of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels, or directly through a biperm. The output satisfies A * Nᴴ' ≈ 0 and Nᴴ * Nᴴ' ≈ I.\n\nKeyword arguments\n\natol::Real=0: absolute tolerance for the nullspace computation.\nrtol::Real=0: relative tolerance for the nullspace computation.\nkind::Symbol: specify the kind of decomposition used to compute the nullspace. The options are :lq, :lqpos and :svd. The former two require 0 == atol == rtol. The default is :lqpos if atol == rtol == 0, and :svd otherwise.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TensorAlgebra.right_orth","page":"Reference","title":"TensorAlgebra.right_orth","text":"right_orth(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> C, V\nright_orth(A::AbstractArray, biperm::BlockedPermutation{2}; kwargs...) -> C, V\n\nCompute the right orthogonal decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels, or directly through a biperm.\n\nKeyword arguments\n\nKeyword arguments are passed on directly to MatrixAlgebraKit.\n\nSee also MatrixAlgebraKit.right_orth!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.right_polar","page":"Reference","title":"TensorAlgebra.right_polar","text":"right_polar(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> P, W\nright_polar(A::AbstractArray, biperm::BlockedPermutation{2}; kwargs...) -> P, W\n\nCompute the right polar decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels, or directly through a biperm.\n\nKeyword arguments\n\nKeyword arguments are passed on directly to MatrixAlgebraKit.\n\nSee also MatrixAlgebraKit.right_polar!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TensorAlgebra.svd-Tuple{AbstractArray, Any, Any, Any}","page":"Reference","title":"TensorAlgebra.svd","text":"svd(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> U, S, Vᴴ\nsvd(A::AbstractArray, biperm::BlockedPermutation{2}; kwargs...) -> U, S, Vᴴ\n\nCompute the SVD decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels, or directly through a biperm.\n\nKeyword arguments\n\nfull::Bool=false: select between a \"thick\" or a \"thin\" decomposition, where both U and Vᴴ are unitary or isometric.\ntrunc: Truncation keywords for svd_trunc. Not compatible with full=true.\nOther keywords are passed on directly to MatrixAlgebraKit.\n\nSee also MatrixAlgebraKit.svd_full!, MatrixAlgebraKit.svd_compact!, and MatrixAlgebraKit.svd_trunc!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TensorAlgebra.svdvals-Tuple{AbstractArray, Any, Any, Any}","page":"Reference","title":"TensorAlgebra.svdvals","text":"svdvals(A::AbstractArray, labels_A, labels_codomain, labels_domain) -> S\nsvdvals(A::AbstractArray, biperm::BlockedPermutation{2}) -> S\n\nCompute the singular values of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels, or directly through a biperm. The output is a vector of singular values.\n\nSee also MatrixAlgebraKit.svd_vals!.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"EditURL = \"../../examples/README.jl\"","category":"page"},{"location":"#TensorAlgebra.jl","page":"Home","title":"TensorAlgebra.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue) (Image: Aqua)","category":"page"},{"location":"#Support","page":"Home","title":"Support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<img class=\"display-light-only\" src=\"assets/CCQ.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n<img class=\"display-dark-only\" src=\"assets/CCQ-dark.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>","category":"page"},{"location":"","page":"Home","title":"Home","text":"TensorAlgebra.jl is supported by the Flatiron Institute, a division of the Simons Foundation.","category":"page"},{"location":"#Installation-instructions","page":"Home","title":"Installation instructions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package resides in the ITensor/ITensorRegistry local registry. In order to install, simply add that registry through your package manager. This step is only required once.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, the package can be added as usual through the package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.add(\"TensorAlgebra\")","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using TensorAlgebra: TensorAlgebra","category":"page"},{"location":"","page":"Home","title":"Home","text":"Examples go here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This page was generated using Literate.jl.","category":"page"}]
}
